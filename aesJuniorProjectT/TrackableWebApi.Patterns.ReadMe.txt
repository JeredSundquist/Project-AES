Trackable Web API with Repository and Unit of Work ReadMe

This solutions demonstrates using Trackable Entities with the Repository
and Unit of Work patterns to abstract away the underlying data access
technology.  This allows for greater flexibility and the ability to switch
from one data provider to another without re-writing application code.

NOTE: You can use the EF 6.x Tools for Visual Studio to reverse
engineer both client and service trackable entities:
http://www.microsoft.com/en-us/download/details.aspx?id=40762.
Add an "ADO.NET Entity Data Model" and select "Code First from Database."
However, the EF 6.x Tools are not compatible with the Client.Entities
project, which is a Portable Class Library. Either add client entities
to a .NET 4.5 Class Library and copy or link them to Client.Entities,
or use the Entity Framework Power Tools to generate client entities:
http://visualstudiogallery.msdn.microsoft.com/72a60b14-1581-4b9b-89f2-846072eff19d.

You can also generate client and service trackable entities using a Model-
First approach, by adding an ADO.NET Entity Data Model and selecting
"EF Designer from Database." Then right-click the model design surface,
select "Add Code Generation Item," and choose either a Client or Service
Trackable Entities EF 6.x Model First Generator, entering the same name
as the existing model and responding "Yes" to the prompts to replace
existing .tt files.

These steps use a scaled down version of the Northwind database, which you 
can get here: http://bit.ly/northwindslim.

Before starting the client Console app, build the solution, then right-click 
on the Web Api project and select View in Browser. This will start the service 
using the IIS Express web server.

1. Reverse engineer a database for the Service.Entities project
   - Right-click on the project, select Entity Framework,
	 Reverse Engineer Code First.
	 > Enter the connection information: server, database name
	 > For these steps we are using the NorthwindSlim database
   - Build the solution

2. Copy the connection string from App.config in Service.Entities
   - Paste it into the connectionStrings section of the web.config
	 file in the Service.WebApi project

3. Add Repository Interfaces to the Service.Persistence project.
   - Right-click the Repositories folder, Add New Item, Trackable category,
	 select "Entity Repository Interface"
	 > Enter an interface name, for example: ICustomerRepository
	 > Select a trackable entity from the drop down in wizard, 
	   for example: Customer
	   - NOTE: If needed change the parameter type for the Get and Delete methods
		 to match the primary key property of the entity, for example:
		 Task<Customer> GetCustomer(string id);
		 Task<bool> DeleteCustomer(string id);
	 > Enter the entity set name for the entity, for example: Customers
	   Add other methods to query entities as needed, for example:
	   Task<IEnumerable<Order>> GetOrders(string customerId);
	 > Add other entity repository interfaces as needed, for example:
	   IOrderRepository

4. Add Unit of Work Interfaces to the Service.Persistence project.
   - Right-click the UnitsOfWork folder, Add New Item, Trackable category,
	 select "Example Unit of Work Interface"
	 > Enter a name, for example: INorthwindUnitOfWork
	 > Add read-only properties for each entity repository interface, for example:
	   ICustomerRepository CustomerRepository { get; }
	   IOrderRepository OrderRepository { get; }
	   - NOTE: You will need to resolve namespaces for the Entity Repository Interfaces
		 by adding the required using directives.

5. Add a Database Context Interface to the Service.EF project
   - Right-click the Contexts folder, Add New Item, Trackable category,
	 select "Database Context Interface"
	 > Enter an interface name, for example: INorthwindSlimContext
	 > Add IDbSet<Entity> properties for each entity set on the DbContext class, for example:
	   IDbSet<Category> Categories { get; set; }
	   IDbSet<Customer> Customers { get; set; }
	   IDbSet<Order> Orders { get; set; }
	   IDbSet<OrderDetail> OrderDetails { get; set; }
	   IDbSet<Product> Products { get; set; }
	   - NOTE: You will need to resolve namespaces for the entity classes by adding the 
		 required using directive.
   - Now copy the DbContext generated by the EF Power Tools from the Service.Entities project
	 over to the Contexts folder in the Service.EF project, for example: NorthwindSlimContext
	 > Remember to delete the DbContext class from the Service.Entities project
	 > Change the namespace in which the DbContext class appears to match that of the
	   Service.EF project
	   - NOTE: You will need to resolve namespaces for the entity classes by adding the 
		 required using directive.
   - You should also move classes from the Mapping folder in the Service.Entities project
     over to the Mapping folder in the Service.EF project.
	 > Remember to remove mapping classes altogether from the Service.Entities project.
   - Next, modify the DbContext class to implement the Database Context Interface you just added,
	 for example: public partial class NorthwindSlimContext : DbContext, INorthwindSlimContext
	 > Then change each DbSet property to IDbSet, so that interface is implemented
   - Build the solution to make sure everything compiles

6. Add Entity Repository Classes to the Service.EF project
   - Right-click the Repositories folder, Add New Item, Trackable category,
	 select "Entity Repository Class"
	 > Enter an class name, for example: CustomerRepository
	 > Select a trackable entity from the drop down list in the wizard
	   and enter an entity set name, for example: Customer, Customers
	   - NOTE: If needed change the parameter type for the Get and Delete methods
		 to match the primary key property of the entity, for example:
		 Task<Customer> GetCustomer(string id);
		 Task<bool> DeleteCustomer(string id);
	 > Rename IDatabaseContext to match the name of the Database Context Interface
	   you added earlier, for example: INorthwindSlimContext
	 > Add other Entity Repository Classes as needed, for example, OrderRepository,
	   replacing the Data Context Interface as before
	 > Implement other methods defined on the IOrderRepository interface:
	   public Task<IEnumerable<Order>> GetOrders(string customerId)
	 > Add Include statements as needed to the Get methods for including child entities:

		public async Task<IEnumerable<Order>> GetOrders()
		{
			IEnumerable<Order> orders = await _context.Orders
				.Include(o => o.Customer)
				.Include("OrderDetails.Product")
				.ToListAsync();
			return orders;
		}

		public async Task<IEnumerable<Order>> GetOrders(string customerId)
		{
			IEnumerable<Order> orders = await _context.Orders
				.Include(o => o.Customer)
				.Include("OrderDetails.Product")
				.Where(o => o.CustomerId == customerId)
				.ToListAsync();
			return orders;
		}

		public async Task<Order> GetOrder(int id)
		{
			Order order = await _context.Orders
				 .Include(o => o.Customer)
				 .Include("OrderDetails.Product")
				 .SingleOrDefaultAsync(o => o.OrderId == id);
			return order;
		}

   - Build the solution to make sure everything compiles

7. Add a Unit of Work class to the Service.EF project
   - Right-click the UnitsOfWork folder, Add New Item, Trackable category,
	 select "Example Unit of Work Class"
	 > Enter a class name that matches the Unit of Work Interface added earlier
	   to the Service.Persistence project, for example: NorthwindUnitOfWork
   - Add read-only fields for each entity repository interface, for example:
	 private readonly IProductRepository _productRepository
   - Modify the class ctor by renaming IDatabaseContext to match the context
	 interface you added earlier, for example: INorthwindSlimContext
	 > Then add repository interface parameters for each field you added,
	   for example: IProductRepository productRepository
	 > Initialize each entity repository field using the ctor parameters,
	   for example:

		private readonly ICustomerRepository _customerRepository;
		private readonly IOrderRepository _orderRepository;

		public NorthwindUnitOfWork(INorthwindSlimContext context,
			ICustomerRepository customerRepository,
			IOrderRepository orderRepository) :
			base(context as DbContext)
		{
			_customerRepository = customerRepository;
			_orderRepository = orderRepository;
		}

   - Next add read-only property for each entity repository interface, for example:

		public ICustomerRepository CustomerRepository
		{
			get { return _customerRepository; }
		}

		public IOrderRepository OrderRepository
		{
			get { return _orderRepository; }
		}

   - Lastly add a using directive to resolve the Exception classes namespace:
	 using WebApiSample.Service.Persistence.Exceptions
	 > Also resolve any another namespaces as needed
	   NOTE: Resolve the namespaces for Contexts, Exceptions, Repositories, UnitsOfWork

   - Build the solution to make sure everything compiles

8. Add Entity Web API Controllers to the WebApi project
   - Right-click the Controllers folder, Add New Item, Trackable category,
	 select "Entity Web API Controller"
	 > Enter a name that matches an entity, for example: CustomerController
   - Rename IExampleUnitOfWork to match Unit of Work Interface added to Persistence project
	 For example: INorthwindUnitOfWork
	   - NOTE: If needed change the parameter type for the Get and Delete methods
		 to match the primary key property of the entity, for example:
		 Task<Customer> GetCustomer(string id);
		 Task<bool> DeleteCustomer(string id);
   - Add other contollers as needed, for example: OrderController
   - Add other Get methods supported by the Entity Repository Interface, for example:

	// GET api/Order?customerId=ABCD
	[ResponseType(typeof(IEnumerable<Order>))]
	public async Task<IHttpActionResult> GetOrders(string customerId)
	{
		IEnumerable<Order> orders = await _unitOfWork.OrderRepository.GetOrders(customerId);
		return Ok(orders);
	}

   - Build the solution to make sure everything compiles

9. Configure the IoC container to register required types on startup of the WebApi app
   - Open SimpleInjectorWebApiInitializer.cs from with the App_Start folder
   - Uncomment the using directives: EF.Contexts, EF.Repositories, EF.UnitsOfWork, 
	 Persistence.Repositories, Persistence.UnitsOfWork
   - Register Context, UnitofWork and Repositories with the container.
	 > For this example, simply uncomment the four lines of code in IoCConfig:

	container.RegisterWebApiRequest<INorthwindSlimContext, NorthwindSlimContext>();
	container.RegisterWebApiRequest<INorthwindUnitOfWork, NorthwindUnitOfWork>();
	container.RegisterWebApiRequest<ICustomerRepository, CustomerRepository>();
	container.RegisterWebApiRequest<IOrderRepository, OrderRepository>();

10. Run the Web Api project to test the controller
	- Press F5 or Ctrl+F5 to run the WebApi project
	- Click the API link on the home page
	- Select an operation, such as GetCustomers or GetOrder
	- Click the Test API button, fill out the form and click Send
	  > You should see JSON for the response body

11. Reverse engineer trackable entities for Client.Entities project
	- Right-click, Entity Framework, Reverse Engineer Code First
	  > Enter the connection information: server, database name
	  > For this sample we are using the NorthwindSlim database
	- Delete the Mapping folder
	- Delete the data context class: NorthwindSlimContext
	- Build the solution

12. Lastly, flesh out code in the ConsoleClient project to invoke
	controller actions for the Web API service.
	- Uncomment code in Program.Main
	- If needed replace the port number for HttpClient with that shown in the
	  Web API home page.
	- Set the ConsoleClient project as the startup project for the solution,
	  then press F5 or Ctrl+F5 to run the console client app
	- Press Enter to start the client
	  > You should see all the customers in the database printed to the console
	  > Enter a customer id to retrieve orders for that customer, for example: ALFKI
		You should see a list of orders for the selected customer
	  > Enter one of the order id's shown to retrieve that order with details
	- Then press Etner to create a new order for the selected customer
	  You should see a new order with three new order details
	- Press Enter to update the newly created order
	  You should see that the the first order detail's price has increased,
	  the second order detail was deleted, the third order detail was left unchanged,
	  and a new order detail was added
	- Press Enter to delete the udpated order
	- Press Enter to exit the console app
	- NOTE: To debug the ConsoleClient and WebApi project at the same time, simply
	  set the startup projects for the solution to start both. Then set a breakpoint
	  in the desired controller action.